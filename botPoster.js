const mongoose = require("mongoose");
const axios = require("axios");
const bcrypt = require("bcryptjs");
const dotenv = require("dotenv");
const cron = require("node-cron");
const { OpenAI } = require("openai");

const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
});

dotenv.config();

const User = require("./models/User");
const Idea = require("./models/Idea");

mongoose.connect(process.env.MONGO_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
}).then(() => {
    console.log("âœ… MongoDB connected for botPoster");
}).catch(err => {
    console.error("âŒ MongoDB connection error:", err.message);
});

cron.schedule("0 */4 * * *", async () => {
    if (process.env.ENABLE_BOTS !== "true") {
        console.log("ğŸ›‘ Bot posting is disabled (.env)");
        return;
    }

    try {
        await postBotIdea();
    } catch (err) {
        console.error("âŒ Error in bot posting:", err.message);
    }
});

async function getRealUserInfo() {
    try {
        const res = await axios.get("https://randomuser.me/api/");
        const user = res.data.results[0];

        return {
            username: user.login.username.replace(/[^a-zA-Z0-9_]/g, ""),
            email: user.email,
        };
    } catch (err) {
        console.error("âš ï¸ Using fallback username/email");
        return {
            username: "User" + Math.floor(Math.random() * 100000),
            email: `user${Math.floor(Math.random() * 100000)}@gmail.com`,
        };
    }
}


async function postBotIdea() {
    const existingBots = await User.find({ isBot: true });

    const useExisting = existingBots.length > 0 && Math.random() < 0.5;
    let botUser;

    if (useExisting) {
        botUser = existingBots[Math.floor(Math.random() * existingBots.length)];
    } else {
        const { username, email } = await getRealUserInfo();
        const hashedPassword = await bcrypt.hash("botsecure123", 10);

        botUser = await User.create({
            username,
            email,
            password: hashedPassword,
            isBot: true,
        });

        console.log(`ğŸ†• New bot registered: ${username}`);
    }

    const gptIdea = await generateIdeaFromGPT();
    if (!gptIdea) return;

    const newIdea = new Idea({
        title: gptIdea,
        description: "This idea was auto-generated by a background bot using GPT.",
        tags: ["startup", "innovation", "ai"],
        industry: "Technology",
        createdBy: botUser._id,
    });

    await newIdea.save();
    console.log(`âœ… GPT idea posted by ${botUser.username}: ${gptIdea}`);
}


async function generateIdeaFromGPT() {
    try {
        const res = await openai.chat.completions.create({
            model: "gpt-3.5-turbo",
            messages: [
                {
                    role: "system",
                    content: "You are a creative assistant that generates unique startup ideas.",
                },
                {
                    role: "user",
                    content: "Give me a new startup idea in 1 short sentence.",
                },
            ],
            temperature: 0.9,
        });

        return res.choices[0].message.content.trim();
    } catch (err) {
        console.error("âŒ GPT idea generation failed:", err.message);
        return null;
    }
}
